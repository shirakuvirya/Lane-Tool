<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>High-Performance Waypoint Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    html, body { height:100%; margin:0; background:#0b0e14; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { position:fixed; inset:0; cursor: default; }
    #app.draggable { cursor: grab; }
    #app.delete-mode { cursor: crosshair; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(20,24,33,0.7); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px; padding: 8px 10px; color:#eaeefb; backdrop-filter: blur(6px);
    }
    button, label, select {
      background:#2a2f3a; color:#fff; border:1px solid #3a4150; border-radius:8px;
      padding:8px 12px; cursor:pointer; font-size:14px;
    }
    select {
        -webkit-appearance: none; -moz-appearance: none; appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 12px top 50%;
        background-size: .65em auto;
        padding-right: 30px;
    }
    button:hover, label:hover, select:hover { background:#343b49; }
    button:disabled { background: #222; color: #555; border-color: #333; cursor: not-allowed; }
    .hint-bar {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      color:#9fb0d0; font-size: 13px; opacity: 0.9; user-select:none;
      background: rgba(20,24,33,0.6); padding: 6px 10px; border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08); text-align: center;
    }
    input[type="file"] { display:none; }
    #loader {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: #fff; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
        z-index: 100; display: none;
    }
    #info-panel {
        position: fixed; top: 12px; right: -300px; width: 260px;
        background: rgba(20,24,33,0.8); border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px; padding: 15px; color: #eaeefb;
        backdrop-filter: blur(8px); transition: right 0.3s ease-in-out; z-index: 10;
    }
    #info-panel.visible { right: 12px; }
    #info-panel h3 {
        margin-top: 0; margin-bottom: 15px; color: #fff; font-weight: 500;
        border-bottom: 1px solid #3a4150; padding-bottom: 10px;
    }
    .info-grid {
        display: grid; grid-template-columns: 50px 1fr; gap: 8px; font-size: 14px;
    }
    .info-grid label {
        font-weight: 500; color: #9fb0d0; background: none; border: none; padding: 0;
    }
    .info-grid span {
        font-family: monospace; background: #0b0e14; padding: 4px 8px;
        border-radius: 4px; color: #c8d3f5;
    }
    #edit-toolbar {
        display: none; /* Hidden by default */
        gap: 8px;
    }
    #edit-toolbar button.active {
        background-color: #5476ff;
        border-color: #839eff;
    }
    #camera-mode-indicator {
        position: fixed; bottom: 45px; left: 50%;
        transform: translateX(-50%);
        background: rgba(84, 118, 255, 0.8); color: #fff;
        padding: 8px 14px; border-radius: 8px; font-size: 14px;
        font-weight: 500; z-index: 20; display: none; backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="ui">
    <label for="map-file">Open Map (.ply/.pcd)</label>
    <input id="map-file" type="file" accept=".ply,.pcd" />
    <span style="border-left: 1px solid #444; margin: 0 4px;"></span>
    <label for="waypoint-file">Open Waypoints (.db)</label>
    <input id="waypoint-file" type="file" accept=".db,.sqlite" />
    <button id="new-waypoints">New Waypoint Set</button>
    <button id="save-waypoints" disabled>Save Waypoints (.db)</button>
    <span style="border-left: 1px solid #444; margin: 0 4px;"></span>
    <button id="edit" disabled>Toggle Edit Mode</button>
    <div id="edit-toolbar">
        <button id="edit-add">Add</button>
        <button id="edit-move">Move</button>
        <button id="edit-delete">Delete</button>
        <button id="edit-select" class="active">Select</button>
    </div>
    <select id="view-select">
      <option value="perspective">Perspective View</option>
      <option value="top">Top-Down View</option>
      <option value="front">Front View</option>
      <option value="side">Side View</option>
    </select>
    <button id="lock-rotation">Lock Rotation</button>
  </div>
  
  <div id="loader">Loading Waypoints...</div>

  <div id="info-panel">
    <h3>Selected Waypoint</h3>
    <div class="info-grid">
      <label>X:</label> <span id="info-x">0.00</span>
      <label>Y:</label> <span id="info-y">0.00</span>
      <label>Z:</label> <span id="info-z">0.00</span>
    </div>
    <h3 style="margin-top: 15px;">Orientation</h3>
    <div class="info-grid">
      <label>Roll:</label> <span id="info-roll">0.00</span>
      <label>Pitch:</label> <span id="info-pitch">0.00</span>
      <label>Yaw:</label> <span id="info-yaw">0.00</span>
    </div>
  </div>

  <div id="hint" class="hint-bar">
    Orbit: Left-drag • Pan: Right-drag • Zoom: Wheel
  </div>
  <div id="hint-edit" class="hint-bar" style="display:none;">
    <span id="edit-mode-hint">Click a start and end point to select a path.</span> <b>Hold Ctrl for camera.</b>
  </div>
  <div id="camera-mode-indicator"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PLYLoader }  from 'three/addons/loaders/PLYLoader.js';
    import { PCDLoader }  from 'three/addons/loaders/PCDLoader.js';

    // --- Basic setup ---
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e14);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);
    
    // --- Global Camera and Controls ---
    let camera;
    let controls;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 2, 3);
    scene.add(directionalLight);
    const gridHelper = new THREE.GridHelper(10, 20, 0x3d4a66, 0x202838);
    gridHelper.rotation.x = Math.PI / 2;
    scene.add(gridHelper);

    // --- App State ---
    let mapObject = null;
    let waypointsObject = null;
    let editMode = false;
    let editSubMode = 'select';
    let selectedIndices = new Set();
    let isDragging = false;
    let isRotationLocked = false; 
    let isCameraOverrideActive = false;
    let indexToDbId = [];
    let dynamicPointSize = 0.05;
    let pathSelectionStartIndex = null; // NEW
    
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.05;
    const pointer = new THREE.Vector2();
    const raycastPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const infoPanel = document.getElementById('info-panel');
    const hintMain = document.getElementById('hint');
    const editToolbar = document.getElementById('edit-toolbar');
    const cameraModeIndicator = document.getElementById('camera-mode-indicator');
    let dragStart3D, initialDragPositions;

    // --- Database Setup ---
    let db = null;
    let SQL = null;
    const WAYPOINT_TABLE_SQL = `
      CREATE TABLE IF NOT EXISTS waypoints (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          x REAL NOT NULL, y REAL NOT NULL, z REAL NOT NULL,
          roll REAL DEFAULT 0, pitch REAL DEFAULT 0, yaw REAL DEFAULT 0
      );`;

    async function initDatabase() {
        SQL = await initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}` });
    }

    // --- Waypoint Loading and Management ---
    function clearVisualWaypoints() {
        if (waypointsObject) {
            scene.remove(waypointsObject);
            waypointsObject.geometry.dispose();
            waypointsObject.material.dispose();
            waypointsObject = null;
        }
        clearSelection();
        indexToDbId = [];
    }

    async function refreshWaypointsFromDB() {
        clearVisualWaypoints();
        if (!db) return;

        const stmt = db.prepare("SELECT id, x, y, z FROM waypoints;");
        const positions = [];
        indexToDbId = [];

        while (stmt.step()) {
            const row = stmt.get();
            indexToDbId.push(row[0]);
            positions.push(row[1], row[2], row[3]);
        }
        stmt.free();

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            size: dynamicPointSize,
            vertexColors: true, 
        });

        waypointsObject = new THREE.Points(geometry, material);
        updateAllColors();
        scene.add(waypointsObject);
        
        if (waypointsObject && camera) {
            waypointsObject.material.size = camera.isPerspectiveCamera ? dynamicPointSize : 3.0;
            waypointsObject.material.sizeAttenuation = camera.isPerspectiveCamera;
            waypointsObject.material.needsUpdate = true;
        }
    }

    async function loadWaypointsFromFile(file) {
        if (!SQL) return alert("Database engine is not ready.");
        
        if (db) { db.close(); db = null; }
        clearVisualWaypoints();
        document.getElementById('loader').style.display = 'block';
        await new Promise(resolve => setTimeout(resolve, 50));

        try {
            const buffer = await file.arrayBuffer();
            db = new SQL.Database(new Uint8Array(buffer));
            const res = db.exec("SELECT name FROM sqlite_master WHERE type='table' AND name='waypoints';");
            if (res.length === 0) throw new Error("Database does not contain a 'waypoints' table.");
        } catch (err) {
            alert(`Error loading database: ${err.message}`);
            db = null;
        }
        
        await refreshWaypointsFromDB();
        
        updateButtonState();
        document.getElementById('loader').style.display = 'none';
        setView(viewSelect.value);
    }

    function createNewWaypointSet() {
        if (!SQL) return alert("Database engine is not ready.");
        if (db) db.close();
        
        db = new SQL.Database();
        db.run(WAYPOINT_TABLE_SQL);
        refreshWaypointsFromDB();
        updateButtonState();
    }

    function saveWaypointsToDB() {
        if (!db) return;
        const data = db.export();
        const blob = new Blob([data], { type: "application/x-sqlite3" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `waypoints_${Date.now()}.db`;
        link.click();
        URL.revokeObjectURL(link.href);
    }
    
    // --- Point Manipulation ---
    async function addPoint(position) {
        if (!db) return;
        db.run("INSERT INTO waypoints (x, y, z) VALUES (?, ?, ?)", [position.x, position.y, position.z]);
        await refreshWaypointsFromDB();
    }

    function updatePointsInDb(positionsMap) {
        if (!db) return;
        const stmt = db.prepare("UPDATE waypoints SET x = ?, y = ?, z = ? WHERE id = ?");
        for (const [id, pos] of positionsMap.entries()) {
            stmt.run([pos.x, pos.y, pos.z, id]);
        }
        stmt.free();
    }

    async function deleteSelectedPoints() {
        if (!db || selectedIndices.size === 0) return;
        const idsToDelete = Array.from(selectedIndices).map(index => indexToDbId[index]);
        if (idsToDelete.length === 0) return;
        const placeholders = idsToDelete.map(() => '?').join(',');
        db.run(`DELETE FROM waypoints WHERE id IN (${placeholders})`, idsToDelete);
        await refreshWaypointsFromDB();
    }

    function clearSelection() {
        selectedIndices.clear();
        pathSelectionStartIndex = null;
        updateAllColors();
        updateInfoPanel();
    }
    
    function updateAllColors() {
        if (!waypointsObject) return;
        const positions = waypointsObject.geometry.attributes.position;
        const colors = new Float32Array(positions.count * 3);
        const selectedColor = new THREE.Color(0xff8800); // Orange
        const defaultColor = new THREE.Color(0xffff00); // Yellow
        const startColor = new THREE.Color(0x00ff00); // Green

        for (let i = 0; i < positions.count; i++) {
            let color = defaultColor;
            if (i === pathSelectionStartIndex) {
                color = startColor;
            } else if (selectedIndices.has(i)) {
                color = selectedColor;
            }
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        waypointsObject.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    }
    
    function updateInfoPanel() {
        if (selectedIndices.size === 1) {
            const index = selectedIndices.values().next().value;
            const db_id = indexToDbId[index];
            const stmt = db.prepare("SELECT x, y, z, roll, pitch, yaw FROM waypoints WHERE id = :id");
            const result = stmt.getAsObject({':id': db_id});
            stmt.free();

            if (result.x !== undefined) {
                infoPanel.querySelector('h3').textContent = `Waypoint #${db_id}`;
                document.getElementById('info-x').textContent = result.x.toFixed(4);
                document.getElementById('info-y').textContent = result.y.toFixed(4);
                document.getElementById('info-z').textContent = result.z.toFixed(4);
                document.getElementById('info-roll').textContent = result.roll.toFixed(4);
                document.getElementById('info-pitch').textContent = result.pitch.toFixed(4);
                document.getElementById('info-yaw').textContent = result.yaw.toFixed(4);
                infoPanel.classList.add('visible');
            }
        } else if (selectedIndices.size > 1) {
            infoPanel.querySelector('h3').textContent = `${selectedIndices.size} Waypoints Selected`;
            document.getElementById('info-x').textContent = '---';
            document.getElementById('info-y').textContent = '---';
            document.getElementById('info-z').textContent = '---';
            document.getElementById('info-roll').textContent = '---';
            document.getElementById('info-pitch').textContent = '---';
            document.getElementById('info-yaw').textContent = '---';
            infoPanel.classList.add('visible');
        } else {
            infoPanel.classList.remove('visible');
        }
    }
    
    // --- Event Listeners ---
    function onPointerDown(event) {
        if (!editMode || !waypointsObject || isCameraOverrideActive) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);

        const intersects = raycaster.intersectObject(waypointsObject);
        
        switch (editSubMode) {
            case 'add':
                const intersectionAdd = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(raycastPlane, intersectionAdd)) addPoint(intersectionAdd);
                break;
            case 'select':
                if (intersects.length > 0) {
                    const clickedIndex = intersects[0].index;
                    if (pathSelectionStartIndex === null) {
                        clearSelection();
                        pathSelectionStartIndex = clickedIndex;
                        selectedIndices.add(clickedIndex);
                    } else {
                        const start = Math.min(pathSelectionStartIndex, clickedIndex);
                        const end = Math.max(pathSelectionStartIndex, clickedIndex);
                        for (let i = start; i <= end; i++) {
                            selectedIndices.add(i);
                        }
                        pathSelectionStartIndex = null;
                    }
                    updateAllColors();
                    updateInfoPanel();
                } else {
                    clearSelection();
                }
                break;
            case 'move':
                if (intersects.length > 0 && selectedIndices.has(intersects[0].index)) {
                    isDragging = true;
                    controls.enabled = false;
                    app.classList.add('draggable');
                    
                    const intersectionMove = new THREE.Vector3();
                    if (raycaster.ray.intersectPlane(raycastPlane, intersectionMove)) {
                       dragStart3D = intersectionMove;
                       initialDragPositions = new Map();
                       const positions = waypointsObject.geometry.attributes.position;
                       for (const index of selectedIndices) {
                           initialDragPositions.set(index, new THREE.Vector3().fromBufferAttribute(positions, index));
                       }
                    }
                }
                break;
            case 'delete':
                if (intersects.length > 0) {
                    const clickedIndex = intersects[0].index;
                    if (!selectedIndices.has(clickedIndex)) {
                        clearSelection();
                        selectedIndices.add(clickedIndex);
                    }
                    deleteSelectedPoints();
                }
                break;
        }
    }

    function onPointerMove(event) {
        if (isCameraOverrideActive || !editMode || !isDragging || selectedIndices.size === 0 || !waypointsObject) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        
        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(raycastPlane, intersection)) {
            const delta = new THREE.Vector3().subVectors(intersection, dragStart3D);
            const positions = waypointsObject.geometry.attributes.position;
            
            for (const [index, initialPos] of initialDragPositions.entries()) {
                const newPos = new THREE.Vector3().addVectors(initialPos, delta);
                positions.setXYZ(index, newPos.x, newPos.y, newPos.z);
            }
            positions.needsUpdate = true;
            updateInfoPanel();
        }
    }

    function onPointerUp(event) {
        if (isCameraOverrideActive) return;

        if (isDragging) {
            isDragging = false;
            controls.enabled = true;
            app.classList.remove('draggable');

            const positionsToUpdate = new Map();
            const positions = waypointsObject.geometry.attributes.position;
            for (const index of selectedIndices) {
                const db_id = indexToDbId[index];
                const pos = new THREE.Vector3().fromBufferAttribute(positions, index);
                positionsToUpdate.set(db_id, pos);
            }
            updatePointsInDb(positionsToUpdate);
        }
    }
    
    // --- UI Wiring ---
    const mapFileInput = document.getElementById('map-file');
    const waypointFileInput = document.getElementById('waypoint-file');
    const newWaypointsBtn = document.getElementById('new-waypoints');
    const saveWaypointsBtn = document.getElementById('save-waypoints');
    const editBtn = document.getElementById('edit');
    const viewSelect = document.getElementById('view-select');
    const lockRotationBtn = document.getElementById('lock-rotation');
    
    function updateButtonState() {
        const hasDb = db !== null;
        saveWaypointsBtn.disabled = !hasDb;
        editBtn.disabled = !hasDb;
        if (!hasDb && editMode) toggleEditMode();
    }
    
    function toggleEditMode() {
        editMode = !editMode;
        editBtn.style.background = editMode ? '#5476ff' : '#2a2f3a';
        editToolbar.style.display = editMode ? 'flex' : 'none';
        document.getElementById('hint').style.display = editMode ? 'none' : 'block';
        document.getElementById('hint-edit').style.display = editMode ? 'block' : 'none';
        if (!editMode) clearSelection();
    }
    
    mapFileInput.addEventListener('change', e => e.target.files[0] && onMapFileSelect(e.target.files[0]));
    waypointFileInput.addEventListener('change', e => {
        if (e.target.files[0]) {
            loadWaypointsFromFile(e.target.files[0]);
            e.target.value = '';
        }
    });
    newWaypointsBtn.addEventListener('click', createNewWaypointSet);
    saveWaypointsBtn.addEventListener('click', saveWaypointsToDB);
    editBtn.addEventListener('click', toggleEditMode);
    viewSelect.addEventListener('change', () => setView(viewSelect.value));

    lockRotationBtn.addEventListener('click', () => {
        isRotationLocked = !isRotationLocked;
        if (controls) {
            controls.enableRotate = !isRotationLocked;
        }
        lockRotationBtn.textContent = isRotationLocked ? 'Unlock Rotation' : 'Lock Rotation';
        lockRotationBtn.style.background = isRotationLocked ? '#5476ff' : '#2a2f3a';
    });

    const editModeButtons = {
        add: document.getElementById('edit-add'),
        move: document.getElementById('edit-move'),
        delete: document.getElementById('edit-delete'),
        select: document.getElementById('edit-select'),
    };
    const hintSpan = document.getElementById('edit-mode-hint');

    Object.entries(editModeButtons).forEach(([mode, button]) => {
        button.addEventListener('click', () => {
            if (mode !== 'select') { // If switching away from select mode, finalize any path selection
                pathSelectionStartIndex = null;
                updateAllColors();
            }
            editSubMode = mode;
            Object.values(editModeButtons).forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            app.classList.toggle('delete-mode', mode === 'delete');
            
            // Update hint text
            switch(mode) {
                case 'add': hintSpan.textContent = "Click on the grid to add a waypoint."; break;
                case 'move': hintSpan.textContent = "Click and drag selected points to move them."; break;
                case 'delete': hintSpan.textContent = "Click a waypoint or selection to delete."; break;
                case 'select': hintSpan.textContent = "Click a start and end point to select a path."; break;
            }
        });
    });
    
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    
    function updateCameraModeIndicator(e) {
        if (!isCameraOverrideActive || viewSelect.value === 'perspective') {
            cameraModeIndicator.style.display = 'none';
            return;
        }
        if (e.ctrlKey && e.shiftKey) {
            controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
            cameraModeIndicator.textContent = "Camera Mode: Orbit";
            cameraModeIndicator.style.display = 'block';
        } else if (e.ctrlKey) {
            controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
            cameraModeIndicator.textContent = "Camera Mode: Pan";
            cameraModeIndicator.style.display = 'block';
        }
    }

    window.addEventListener('keydown', (e) => {
        if (editMode && e.key === 'Control' && !isCameraOverrideActive) {
            isCameraOverrideActive = true;
            controls.enabled = true;
            updateCameraModeIndicator(e);
        } else if (editMode && e.key === 'Shift' && isCameraOverrideActive) {
            updateCameraModeIndicator(e);
        } else if (editMode && (e.key === 'Delete' || e.key === 'Backspace')) {
            deleteSelectedPoints();
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
            isCameraOverrideActive = false;
            cameraModeIndicator.style.display = 'none';
            controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE; // Restore default
        } else if (e.key === 'Shift' && isCameraOverrideActive) {
            updateCameraModeIndicator(e); // Re-evaluates to Pan mode
        }
    });


    // --- Helper & View Functions ---
    function onMapFileSelect(file) {
        const url = URL.createObjectURL(file);
        const loader = file.name.toLowerCase().endsWith('.ply') ? new PLYLoader() : new PCDLoader();
        loader.load(url, geometryOrPoints => {
            if (mapObject) scene.remove(mapObject);
            mapObject = geometryOrPoints.isPoints ? geometryOrPoints : new THREE.Points(geometryOrPoints, new THREE.PointsMaterial({ size: 0.01, vertexColors: true}));
            scene.add(mapObject);
            setView(viewSelect.value);
            URL.revokeObjectURL(url);
        });
    }

    function setView(viewType) {
        if (controls) { controls.dispose(); }

        const aspect = window.innerWidth / window.innerHeight;
        let targetObject = mapObject || gridHelper;
        const box = new THREE.Box3().setFromObject(targetObject);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 10;

        if (viewType === 'perspective') {
            camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 10000);
            camera.up.set(0, 0, 1);
            const camDist = maxDim * 1.5;
            camera.position.copy(center).add(new THREE.Vector3(camDist * 0.7, -camDist * 0.7, camDist * 0.7));
            raycastPlane.set(new THREE.Vector3(0, 0, 1), 0); 
        } else {
            const orthoSize = maxDim * 0.6;
            camera = new THREE.OrthographicCamera(-orthoSize * aspect, orthoSize * aspect, orthoSize, -orthoSize, -maxDim * 5, maxDim * 5);
            camera.up.set(0, 0, 1);
            
            if (viewType === 'top') {
                camera.position.set(center.x, center.y, center.z + maxDim);
                raycastPlane.set(new THREE.Vector3(0, 0, 1), 0); 
            } else if (viewType === 'front') {
                camera.position.set(center.x, center.y - maxDim, center.z);
                raycastPlane.set(new THREE.Vector3(0, 1, 0), 0); 
            } else if (viewType === 'side') {
                camera.position.set(center.x + maxDim, center.y, center.z);
                raycastPlane.set(new THREE.Vector3(1, 0, 0), 0); 
            }
        }
        
        camera.lookAt(center);
        
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.copy(center);

        controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        controls.enableRotate = !isRotationLocked;
        controls.minPolarAngle = 0; 
        controls.maxPolarAngle = Math.PI; 

        if (viewType === 'top') {
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = 0;
        } else if (viewType === 'front' || viewType === 'side') {
            controls.minPolarAngle = Math.PI / 2;
            controls.maxPolarAngle = Math.PI / 2;
        }
        
        hintMain.innerHTML = 'Orbit: Left-drag • Pan: Right-drag • Zoom: Wheel';
        dynamicPointSize = Math.max(maxDim / 800, 0.02);
        if (waypointsObject) {
            waypointsObject.material.size = camera.isPerspectiveCamera ? dynamicPointSize : 3.0;
            waypointsObject.material.sizeAttenuation = camera.isPerspectiveCamera;
            waypointsObject.material.needsUpdate = true;
        }
    }


    // --- Animate & Init ---
    function tick(){
      requestAnimationFrame(tick);
      if (controls) controls.update();
      renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        if (!camera) return;
        const aspect = window.innerWidth / window.innerHeight;
        if (camera.isPerspectiveCamera) {
            camera.aspect = aspect;
        } else if (camera.isOrthographicCamera) {
            const orthoSize = (camera.top - camera.bottom) / 2;
            camera.left = -orthoSize * aspect;
            camera.right = orthoSize * aspect;
        }
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initDatabase().then(() => {
        setView('perspective'); // Initialize with a default view
        tick();
    });
  </script>
</body>
</html>

