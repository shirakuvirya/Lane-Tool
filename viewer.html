<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>High-Performance Waypoint Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    html, body { height:100%; margin:0; background:#0b0e14; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { position:fixed; inset:0; cursor: default; }
    #app.draggable { cursor: grab; }
    #app.delete-mode { cursor: crosshair; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(20,24,33,0.7); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px; padding: 8px 10px; color:#eaeefb; backdrop-filter: blur(6px);
    }
    button, label, select {
      background:#2a2f3a; color:#fff; border:1px solid #3a4150; border-radius:8px;
      padding:8px 12px; cursor:pointer; font-size:14px;
    }
    select {
        -webkit-appearance: none; -moz-appearance: none; appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 12px top 50%;
        background-size: .65em auto;
        padding-right: 30px;
    }
    button:hover, label:hover, select:hover { background:#343b49; }
    button:disabled { background: #222; color: #555; border-color: #333; cursor: not-allowed; }
    .hint-bar {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      color:#9fb0d0; font-size: 13px; opacity: 0.9; user-select:none;
      background: rgba(20,24,33,0.6); padding: 6px 10px; border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08); text-align: center;
    }
    input[type="file"] { display:none; }
    #loader {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: #fff; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
        z-index: 100; display: none;
    }
    #info-panel {
        position: fixed; top: 12px; right: -300px; width: 260px;
        background: rgba(20,24,33,0.8); border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px; padding: 15px; color: #eaeefb;
        backdrop-filter: blur(8px); transition: right 0.3s ease-in-out; z-index: 10;
    }
    #info-panel.visible { right: 12px; }
    #info-panel h3 {
        margin-top: 0; margin-bottom: 15px; color: #fff; font-weight: 500;
        border-bottom: 1px solid #3a4150; padding-bottom: 10px;
    }
    .info-grid {
        display: grid; grid-template-columns: 50px 1fr; gap: 8px; font-size: 14px;
    }
    .info-grid label {
        font-weight: 500; color: #9fb0d0; background: none; border: none; padding: 0;
    }
    .info-grid span {
        font-family: monospace; background: #0b0e14; padding: 4px 8px;
        border-radius: 4px; color: #c8d3f5;
    }
    /* --- NEW: Edit Mode Sub-toolbar --- */
    #edit-toolbar {
        display: none; /* Hidden by default */
        gap: 8px;
    }
    #edit-toolbar button.active {
        background-color: #5476ff;
        border-color: #839eff;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="ui">
    <label for="map-file">Open Map (.ply/.pcd)</label>
    <input id="map-file" type="file" accept=".ply,.pcd" />
    <span style="border-left: 1px solid #444; margin: 0 4px;"></span>
    <label for="waypoint-file">Open Waypoints (.db)</label>
    <input id="waypoint-file" type="file" accept=".db,.sqlite" />
    <button id="new-waypoints">New Waypoint Set</button>
    <button id="save-waypoints" disabled>Save Waypoints (.db)</button>
    <span style="border-left: 1px solid #444; margin: 0 4px;"></span>
    <button id="edit" disabled>Toggle Edit Mode</button>
    <!-- NEW: Sub-toolbar for edit actions -->
    <div id="edit-toolbar">
        <button id="edit-add">Add</button>
        <button id="edit-move" class="active">Move</button>
        <button id="edit-delete">Delete</button>
    </div>
    <select id="view-select">
      <option value="perspective">Perspective View</option>
      <option value="top">Top-Down View</option>
      <option value="front">Front View</option>
      <option value="side">Side View</option>
    </select>
    <button id="lock-rotation">Lock Rotation</button>
  </div>
  
  <div id="loader">Loading Waypoints...</div>

  <div id="info-panel">
    <h3>Selected Waypoint</h3>
    <div class="info-grid">
      <label>X:</label> <span id="info-x">0.00</span>
      <label>Y:</label> <span id="info-y">0.00</span>
      <label>Z:</label> <span id="info-z">0.00</span>
    </div>
    <h3 style="margin-top: 15px;">Orientation</h3>
    <div class="info-grid">
      <label>Roll:</label> <span id="info-roll">0.00</span>
      <label>Pitch:</label> <span id="info-pitch">0.00</span>
      <label>Yaw:</label> <span id="info-yaw">0.00</span>
    </div>
  </div>

  <div id="hint" class="hint-bar">
    Orbit: Left-drag • Pan: Right-drag • Zoom: Wheel
  </div>
  <div id="hint-edit" class="hint-bar" style="display:none;">
    <b>Edit Mode:</b> Select a mode (Add, Move, Delete). <b>Hold Ctrl for camera controls.</b>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PLYLoader }  from 'three/addons/loaders/PLYLoader.js';
    import { PCDLoader }  from 'three/addons/loaders/PCDLoader.js';

    // --- Basic setup ---
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e14);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);
    
    // --- Global Camera and Controls ---
    let camera;
    let controls;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(2, 2, 3);
    scene.add(directionalLight);
    const gridHelper = new THREE.GridHelper(10, 20, 0x3d4a66, 0x202838);
    gridHelper.rotation.x = Math.PI / 2;
    scene.add(gridHelper);

    // --- App State ---
    let mapObject = null;
    let waypointsObject = null;
    let editMode = false;
    let editSubMode = 'move'; // NEW: 'add', 'move', 'delete'
    let selectedPointIndex = null;
    let isDragging = false;
    let isRotationLocked = false; 
    let isCameraOverrideActive = false; // NEW: Ctrl key state
    let indexToDbId = [];
    let dynamicPointSize = 0.05;
    
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.05;
    const pointer = new THREE.Vector2();
    const raycastPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const infoPanel = document.getElementById('info-panel');
    const hintMain = document.getElementById('hint');
    const editToolbar = document.getElementById('edit-toolbar');

    // --- Database Setup ---
    let db = null;
    let SQL = null;
    const WAYPOINT_TABLE_SQL = `
      CREATE TABLE IF NOT EXISTS waypoints (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          x REAL NOT NULL, y REAL NOT NULL, z REAL NOT NULL,
          roll REAL DEFAULT 0, pitch REAL DEFAULT 0, yaw REAL DEFAULT 0
      );`;

    async function initDatabase() {
        SQL = await initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}` });
    }

    // --- Waypoint Loading and Management ---
    function clearVisualWaypoints() {
        if (waypointsObject) {
            scene.remove(waypointsObject);
            waypointsObject.geometry.dispose();
            waypointsObject.material.dispose();
            waypointsObject = null;
        }
        selectPoint(null);
        indexToDbId = [];
    }

    async function refreshWaypointsFromDB() {
        clearVisualWaypoints();
        if (!db) return;

        const stmt = db.prepare("SELECT id, x, y, z FROM waypoints;");
        const positions = [];
        const colors = [];
        const defaultColor = new THREE.Color(0xffff00);

        while (stmt.step()) {
            const row = stmt.get();
            indexToDbId.push(row[0]);
            positions.push(row[1], row[2], row[3]);
            colors.push(defaultColor.r, defaultColor.g, defaultColor.b);
        }
        stmt.free();

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: dynamicPointSize,
            vertexColors: true,
            sizeAttenuation: true
        });

        waypointsObject = new THREE.Points(geometry, material);
        scene.add(waypointsObject);
        
        if (waypointsObject && camera) {
            waypointsObject.material.size = camera.isPerspectiveCamera ? dynamicPointSize : 3.0;
            waypointsObject.material.sizeAttenuation = camera.isPerspectiveCamera;
            waypointsObject.material.needsUpdate = true;
        }
    }

    async function loadWaypointsFromFile(file) {
        if (!SQL) return alert("Database engine is not ready.");
        
        if (db) { db.close(); db = null; }
        clearVisualWaypoints();
        document.getElementById('loader').style.display = 'block';
        await new Promise(resolve => setTimeout(resolve, 50));

        try {
            const buffer = await file.arrayBuffer();
            db = new SQL.Database(new Uint8Array(buffer));
            const res = db.exec("SELECT name FROM sqlite_master WHERE type='table' AND name='waypoints';");
            if (res.length === 0) throw new Error("Database does not contain a 'waypoints' table.");
        } catch (err) {
            alert(`Error loading database: ${err.message}`);
            db = null;
        }
        
        await refreshWaypointsFromDB();
        
        updateButtonState();
        document.getElementById('loader').style.display = 'none';
        setView(viewSelect.value);
    }

    function createNewWaypointSet() {
        if (!SQL) return alert("Database engine is not ready.");
        if (db) db.close();
        
        db = new SQL.Database();
        db.run(WAYPOINT_TABLE_SQL);
        refreshWaypointsFromDB();
        updateButtonState();
    }

    function saveWaypointsToDB() {
        if (!db) return;
        const data = db.export();
        const blob = new Blob([data], { type: "application/x-sqlite3" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `waypoints_${Date.now()}.db`;
        link.click();
        URL.revokeObjectURL(link.href);
    }
    
    // --- Point Manipulation ---
    async function addPoint(position) {
        if (!db) return;
        db.run("INSERT INTO waypoints (x, y, z) VALUES (?, ?, ?)", [position.x, position.y, position.z]);
        await refreshWaypointsFromDB();
    }
    
    function updatePointInDb(db_id, position) {
        if (!db) return;
        db.run("UPDATE waypoints SET x = ?, y = ?, z = ? WHERE id = ?", [position.x, position.y, position.z, db_id]);
    }

    async function deletePointByIndex(index) {
        if (index === null) return;
        const db_id = indexToDbId[index];
        db.run("DELETE FROM waypoints WHERE id = ?", [db_id]);
        await refreshWaypointsFromDB(); // Reload to get correct indices
        selectPoint(null);
    }

    function selectPoint(index) {
        if (!waypointsObject || !waypointsObject.geometry.attributes.color) {
            infoPanel.classList.remove('visible');
            return;
        }
        const colors = waypointsObject.geometry.attributes.color;
        if (selectedPointIndex !== null && selectedPointIndex < colors.count) {
            colors.setXYZ(selectedPointIndex, 1.0, 1.0, 0.0);
        }
        selectedPointIndex = index;
        if (selectedPointIndex !== null && selectedPointIndex < colors.count) {
            colors.setXYZ(selectedPointIndex, 1.0, 0.5, 0.0);
            updateInfoPanel(selectedPointIndex);
        } else {
            infoPanel.classList.remove('visible');
        }
        colors.needsUpdate = true;
    }

    function updateInfoPanel(index) {
        if (index === null || !db) {
            infoPanel.classList.remove('visible');
            return;
        }
        const db_id = indexToDbId[index];
        const stmt = db.prepare("SELECT x, y, z, roll, pitch, yaw FROM waypoints WHERE id = :id");
        const result = stmt.getAsObject({':id': db_id});
        stmt.free();

        if (result.x !== undefined) {
            document.getElementById('info-x').textContent = result.x.toFixed(4);
            document.getElementById('info-y').textContent = result.y.toFixed(4);
            document.getElementById('info-z').textContent = result.z.toFixed(4);
            document.getElementById('info-roll').textContent = result.roll.toFixed(4);
            document.getElementById('info-pitch').textContent = result.pitch.toFixed(4);
            document.getElementById('info-yaw').textContent = result.yaw.toFixed(4);
            infoPanel.classList.add('visible');
        } else {
            infoPanel.classList.remove('visible');
        }
    }

    // --- Event Listeners ---
    function onPointerDown(event) {
        if (!editMode || !waypointsObject || isCameraOverrideActive) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);

        const intersects = raycaster.intersectObject(waypointsObject);
        
        switch (editSubMode) {
            case 'add':
                const intersection = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(raycastPlane, intersection)) {
                    addPoint(intersection);
                }
                break;
            case 'move':
                if (intersects.length > 0) {
                    const index = intersects[0].index;
                    selectPoint(index);
                    isDragging = true;
                    controls.enabled = false;
                    app.classList.add('draggable');
                } else {
                    selectPoint(null);
                }
                break;
            case 'delete':
                if (intersects.length > 0) {
                    deletePointByIndex(intersects[0].index);
                }
                break;
        }
    }

    function onPointerMove(event) {
        if (!editMode || !isDragging || selectedPointIndex === null || !waypointsObject || isCameraOverrideActive) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(raycastPlane, intersection)) {
            const positions = waypointsObject.geometry.attributes.position;
            positions.setXYZ(selectedPointIndex, intersection.x, intersection.y, intersection.z);
            positions.needsUpdate = true;
            document.getElementById('info-x').textContent = intersection.x.toFixed(4);
            document.getElementById('info-y').textContent = intersection.y.toFixed(4);
            document.getElementById('info-z').textContent = intersection.z.toFixed(4);
        }
    }

    function onPointerUp(event) {
        if (isCameraOverrideActive) return;

        if (editMode && isDragging && selectedPointIndex !== null) {
            const db_id = indexToDbId[selectedPointIndex];
            const posAttr = waypointsObject.geometry.attributes.position;
            const pos = new THREE.Vector3().fromBufferAttribute(posAttr, selectedPointIndex);
            updatePointInDb(db_id, pos);
            updateInfoPanel(selectedPointIndex);
        }
        isDragging = false;
        if(controls) controls.enabled = true;
        app.classList.remove('draggable');
    }

    // --- UI Wiring ---
    const mapFileInput = document.getElementById('map-file');
    const waypointFileInput = document.getElementById('waypoint-file');
    const newWaypointsBtn = document.getElementById('new-waypoints');
    const saveWaypointsBtn = document.getElementById('save-waypoints');
    const editBtn = document.getElementById('edit');
    const viewSelect = document.getElementById('view-select');
    const lockRotationBtn = document.getElementById('lock-rotation');
    
    function updateButtonState() {
        const hasDb = db !== null;
        saveWaypointsBtn.disabled = !hasDb;
        editBtn.disabled = !hasDb;
        if (!hasDb && editMode) toggleEditMode();
    }
    
    function toggleEditMode() {
        editMode = !editMode;
        editBtn.style.background = editMode ? '#5476ff' : '#2a2f3a';
        editToolbar.style.display = editMode ? 'flex' : 'none';
        document.getElementById('hint').style.display = editMode ? 'none' : 'block';
        document.getElementById('hint-edit').style.display = editMode ? 'block' : 'none';
        if (!editMode) selectPoint(null);
    }
    
    mapFileInput.addEventListener('change', e => e.target.files[0] && onMapFileSelect(e.target.files[0]));
    waypointFileInput.addEventListener('change', e => {
        if (e.target.files[0]) {
            loadWaypointsFromFile(e.target.files[0]);
            e.target.value = '';
        }
    });
    newWaypointsBtn.addEventListener('click', createNewWaypointSet);
    saveWaypointsBtn.addEventListener('click', saveWaypointsToDB);
    editBtn.addEventListener('click', toggleEditMode);
    viewSelect.addEventListener('change', () => setView(viewSelect.value));

    lockRotationBtn.addEventListener('click', () => {
        isRotationLocked = !isRotationLocked;
        if (controls) {
            controls.enableRotate = !isRotationLocked;
        }
        lockRotationBtn.textContent = isRotationLocked ? 'Unlock Rotation' : 'Lock Rotation';
        lockRotationBtn.style.background = isRotationLocked ? '#5476ff' : '#2a2f3a';
    });

    // NEW: Listeners for edit sub-modes
    const editModeButtons = {
        add: document.getElementById('edit-add'),
        move: document.getElementById('edit-move'),
        delete: document.getElementById('edit-delete'),
    };
    Object.entries(editModeButtons).forEach(([mode, button]) => {
        button.addEventListener('click', () => {
            editSubMode = mode;
            Object.values(editModeButtons).forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            app.classList.toggle('delete-mode', mode === 'delete');
        });
    });
    
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);

    window.addEventListener('keydown', (e) => {
        if (editMode && e.key === 'Control') {
            isCameraOverrideActive = true;
            controls.enabled = true; // Make sure camera controls are active
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.key === 'Control') {
            isCameraOverrideActive = false;
        }
    });

    // --- Helper & View Functions ---
    function onMapFileSelect(file) {
        const url = URL.createObjectURL(file);
        const loader = file.name.toLowerCase().endsWith('.ply') ? new PLYLoader() : new PCDLoader();
        loader.load(url, geometryOrPoints => {
            if (mapObject) scene.remove(mapObject);
            mapObject = geometryOrPoints.isPoints ? geometryOrPoints : new THREE.Points(geometryOrPoints, new THREE.PointsMaterial({ size: 0.01, vertexColors: true}));
            scene.add(mapObject);
            setView(viewSelect.value);
            URL.revokeObjectURL(url);
        });
    }

    function setView(viewType) {
        if (controls) { controls.dispose(); }

        const aspect = window.innerWidth / window.innerHeight;
        let targetObject = mapObject || gridHelper;
        const box = new THREE.Box3().setFromObject(targetObject);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 10;

        if (viewType === 'perspective') {
            camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 10000);
            camera.up.set(0, 0, 1);
            const camDist = maxDim * 1.5;
            camera.position.copy(center).add(new THREE.Vector3(camDist * 0.7, -camDist * 0.7, camDist * 0.7));
            raycastPlane.set(new THREE.Vector3(0, 0, 1), 0); 
        } else {
            const orthoSize = maxDim * 0.6;
            camera = new THREE.OrthographicCamera(-orthoSize * aspect, orthoSize * aspect, orthoSize, -orthoSize, -maxDim * 5, maxDim * 5);
            camera.up.set(0, 0, 1);
            
            if (viewType === 'top') {
                camera.position.set(center.x, center.y, center.z + maxDim);
                raycastPlane.set(new THREE.Vector3(0, 0, 1), 0); 
            } else if (viewType === 'front') {
                camera.position.set(center.x, center.y - maxDim, center.z);
                raycastPlane.set(new THREE.Vector3(0, 1, 0), 0); 
            } else if (viewType === 'side') {
                camera.position.set(center.x + maxDim, center.y, center.z);
                raycastPlane.set(new THREE.Vector3(1, 0, 0), 0); 
            }
        }
        
        camera.lookAt(center);
        
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.copy(center);

        controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        controls.enableRotate = !isRotationLocked;
        controls.minPolarAngle = 0; 
        controls.maxPolarAngle = Math.PI; 

        if (viewType === 'top') {
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = 0;
        } else if (viewType === 'front' || viewType === 'side') {
            controls.minPolarAngle = Math.PI / 2;
            controls.maxPolarAngle = Math.PI / 2;
        }
        
        hintMain.innerHTML = 'Orbit: Left-drag • Pan: Right-drag • Zoom: Wheel';
        dynamicPointSize = Math.max(maxDim / 800, 0.02);
        if (waypointsObject) {
            waypointsObject.material.size = camera.isPerspectiveCamera ? dynamicPointSize : 3.0;
            waypointsObject.material.sizeAttenuation = camera.isPerspectiveCamera;
            waypointsObject.material.needsUpdate = true;
        }
    }


    // --- Animate & Init ---
    function tick(){
      requestAnimationFrame(tick);
      if (controls) controls.update();
      renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        if (!camera) return;
        const aspect = window.innerWidth / window.innerHeight;
        if (camera.isPerspectiveCamera) {
            camera.aspect = aspect;
        } else if (camera.isOrthographicCamera) {
            const orthoSize = (camera.top - camera.bottom) / 2;
            camera.left = -orthoSize * aspect;
            camera.right = orthoSize * aspect;
        }
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initDatabase().then(() => {
        setView('perspective'); // Initialize with a default view
        tick();
    });
  </script>
</body>
</html>

